# 20、开发者工具

Spring Boot 包括一组额外的工具，这些工具可以使应用程序开发体验更加愉快。spring-boot-devtools 模块可以包含在任何在任何项目中，以提供额外的开发时特性。要包含 devtools 支持，请将模块依赖项添加到你的构建中，如下面的 Maven 和 Gradle 清单所示：

**Maven**
```
<dependencies>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>
</dependencies>
```
**Gradle**
```
configurations {
developmentOnly
runtimeClasspath {
    extendsFrom developmentOnly
}
}
dependencies {
developmentOnly("org.springframework.boot:spring-boot-devtools")
}
```
注释：在运行完全打包的应用程序时，开发者工具将自动禁用。如果你的应用程序是从 java -jar 启动的，或者是从一个特殊的类加载器启动的，那么它被认为是一个“生产环境的应用”。如果这不适用于你（例如，如果你在容器中运行应用），请考虑排除 devtools 或设置 -Dspring.devtools.restart.enabled=false 系统属性。

提示：在 Maven 中将依赖项标记为可选，或者在 Gradle 中使用自定义的“developmentOnly”配置（如上图所示），这是一种最佳实践，可以防止 devtools 过度地应用于你项目的其他模块。

提示：默认情况下，重新打包的存档文件不包含 devtools。如果要使用某个远程 devtools 功能，则需要禁用 excludeDevtools 构建属性才能包含它。Maven 和 Gradle 插件都支持这个属性。

## 20.1、属性默认值

Spring Boot 支持的几个库使用缓存来提高性能。例如，模板引擎缓存已编译的模板，以避免重复地解析模板文件。另外，Spring MVC 可以在服务静态资源时向响应添加 HTTP 缓存头。

虽然缓存在生产环境中非常有用，但在开发过程中可能适得其反，使你无法看到刚刚在应用程序中所做的更改。因此，默认情况下，spring-boot-devtools 会禁用缓存选项。

缓存选项通常由 application.properties 文件中的设置配置。例如，Thymeleaf 提供 spring.thymeleaf.cache 属性。spring-boot-devtools 模块不需要手动设置这些属性，而是自动应用合理的开发时配置。

由于在开发 Spring MVC 和 Spring WebFlux 应用程序时需要更多关于 web 请求的信息，开发者工具将为 web 日志组启用调试（DEBUG）日志记录。这将提供有关请求、哪个处理程序处理它、响应结果等的信息。如果希望记录所有请求详细信息（包括潜在的敏感信息），可以打开 spring.http.log-request-details 配置属性。

注释：如果不希望应用属性默认值，则可以在 application.properties 文件中设置 spring.devtools.add-properties 为 false。

提示：关于devtools 应用的属性的完整列表，请参见 [DevToolsPropertyDefaultsPostProcessor](https://github.com/spring-projects/spring-boot/tree/v2.1.6.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java)。

## 20.2、自动重启

每当类路径中的文件有变化时，应用程序会使用 spring-boot-devtools 自动地重启。当在 IDE 中工作时，这可能是一个有用的特性，因为它为代码更改提供了非常快速的反馈循环。默认情况下，类路径所指的文件夹中的任何文件都会被监控其变化。请注意，某些资源，例如：静态资产和视图模板，不需要重启应用程序。

**触发重启**

由于 DevTools 监视类路径资源，触发重启的唯一方法是更新类路径。导致类路径更新的方式取决于你使用的 IDE。在 Eclipse 中，保存修改过的文件会导致类路径被更新并触发重启。在 IntelliJ IDEA 中，构建项目（构建->构建项目）具有同样的效果。

注释：只要启用了 forking，你还可以使用支持的构建插件（Maven 和 Gradle）启动应用程序，因为 DevTools 需要一个独立的应用程序类加载器才能正常运行。默认情况下，Gradle 和 Maven 在类路径上检测到 DevTools 时会这样做。

提示：当与 LiveReload 一起使用时，自动重启效果非常好。有关详细信息，请参阅 LiveReload 部分。如果使用 JRebel，则禁用自动重启，以便动态类重新加载。其他 devtools 特性（如 LiveReload 和属性覆盖）仍然可以使用。

注释：DevTools 依赖于应用程序上下文的 shutdown 钩子在重启期间关闭它。如果你禁用了 shutdown 钩子，则无法正常工作。

注释：当决定类路径上的条目在发生更改时是否应该触发重启时，DevTools 会自动忽略名为 spring-boot、spring-boot-devtools、spring-boot-autoconfigure、spring-boot-actuator 和 spring-boot-starter 的项目。

注释：DevTools 需要自定义 ApplicationContext 使用的 ResourceLoader。如果你的应用程序已经提供了一个，它将被包装。不支持直接重写 ApplicationContext 上的 getResource 方法。

**重启和重新加载**

Spring Boot 提供的重启技术通过使用两个类加载器来工作。不改变的类（例如，来自第三方 jar 的类）被加载到基类加载器中。正在积极开发的类将加载到 restart 类加载器中。当应用重启时，restart 类加载器将被丢弃，并创建一个新的类加载器。这种方法意味着应用程序重启通常比“冷启动”快得多，因为基本类加载器已经可用并已填充。

如果发现重启对应用来说不够快，或者遇到类加载问题，则可以考虑重新加载技术，例如来自 ZeroTurnaround 的 JRebel。这些工作是通过在加载类时重写它们，使它们更易于重新加载。

### 20.2.1、记录条件评估中的变化

默认情况下，每次应用程序重启时，都会记录一个显示条件评估增量的报告。该报告显示了在进行更改（如添加或删除 bean 和设置配置属性）时对应用程序自动配置的更改。

要禁用报告的日志记录，请设置以下属性：
```
spring.devtools.restart.log-condition-evaluation-delta=false
```
### 20.2.2、排除资源

某些资源在更改时不一定需要触发重启。例如，可以就地编辑 Thymeleaf 模板。默认情况下，更改在 /META-INF/maven, /META-INF/resources, /resources, /static, /public 或 /templates 中的资源不会触发重启，但会触发实时重新加载。如果你想自定义这些排除项，则你可以使用 spring.devtools.restart.exclude 属性。例如，要只排除 /static 和 /public，你可以设置以下属性：
```
spring.devtools.restart.exclude=static/**,public/**
```
提示：如果想保持这些默认值并添加其他排除项，则使用 spring.devtools.restart.additional-exclude 属性代替。

### 20.2.3、查看其它路径

当你更改不在类路径上的文件时，你可能希望重启或重新加载应用程序。为此，请使用 spring.devtools.restart.additional-paths 属性配置其他路径，以监视更改。你可以使用前面描述的 spring.devtools.restart.exclude 属性来控制附加路径下的更改是触发完全重启还是实时重新加载。

### 20.2.4、禁用重新启动

如果不想使用重启的特性，则可以通过使用 spring.devtools.restart.enabled 属性来禁用它。在大多数情况下，可以在 application.properties 文件中设置这个属性（这样做仍会初始化 restart 类加载器，但它不会监视文件更改）。

如果需要完全禁用 restart 支持（例如，因为它不能和特定的库一起工作），则需要在调用 SpringApplication.run(...) 之前将 spring.devtools.restart.enabled 系统属性设置为 false，如下面示例所示：
```
public static void main(String[] args) {
System.setProperty("spring.devtools.restart.enabled", "false");
SpringApplication.run(MyApp.class, args);
}
```
### 20.2.5、使用触发器文件

如果使用的 IDE 可以持续编译更改的文件，则可能希望仅在特定时间触发重启。为此，你可以使用“触发文件”，这个是一个特殊文件，当你希望实际触发重启检查时，必须对其进行修改。仅当 Devtools 检查到必须执行某些操作时，更改文件才会触发检查并重启。触发器文件可以手动更新，也可以使用 IDE 插件更新。

要使用触发文件，请将 spring.devtools.restart.trigger-file 属性设置为该触发文件的路径。

提示：你可能希望将 spring.devtools.restart.trigger-file 属性作为[全局设置](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/using-boot-devtools.html#using-boot-devtools-globalsettings)，以便所有项目的行为都相同。

### 20.2.6、自定义 restart 类加载器

如前面的重启和重新加载部分所述，重启功能是通过使用两个类加载器实现的。对于大多数应用，这种方法工作得很好。但是，它有时会导致类加载问题。

默认情况下，IDE 中任何打开的项目都用“restart”类加载器加载，而任何常规的 .jar 文件都用“base”类加载器加载。如果在多模块项目上工作，并且不是每个模块都被导入到 IDE 中，则可能需要定制一些东西。为此，可以创建文件 META-INF/spring-devtools.properties。

spring-devtools.properties 文件可以包含前缀为 restart.exclude 和 restart.include 的属性。include 的元素应该放入到 restart 类加载器，exclude 的元素应当放入到 base 类加载器。该属性值是正则匹配，可以应用于类路径，如下面示例所示：
```
restart.exclude.companycommonlibs=/mycorp-common-[\\w\\d-\.]+\.jar
restart.include.projectcommon=/mycorp-myproj-[\\w\\d-\.]+\.jar
```
注释：所有属性的键（key）必须是唯一的。只要属性以“restart.include.”或“restart.exclude.”开头，就会被考虑的。

提示：加载类路径中的所有 META-INF/spring-devtools.properties。你可以在项目内部或项目使用的库中打包文件。

### 20.2.7、已知限制

对于使用标准 ObjectInputStream 反序列化的对象，重启功能不能很好地工作。如果需要反序列化数据，则可能需要结合使用 Spring 的 ConfigurableObjectInputStream 和 Thread.currentThread().getContextClassLoader()。

不幸的是，一些第三方库在反序列化时没有考虑上下文类加载器。如果你发现这样的问题，你需要请求于原始作者修复。

## 20.3、实时重新加载（LiveReload）

spring-boot-devtools 模块包含一个嵌入式 LiveReload 服务器，可以用于在资源更改时触发浏览器刷新。从网站 livereload.com 可以免费获得 Chrome、Firefox 和 Safari 的LiveReload 浏览器扩展。

如果运行应用时不希望启动 LiveReload 服务器，则可以将 spring.devtools.livereload.enabled 属性设置为 false。

注释：一次只能够运行一个 LiveReload 服务器。在启动应用之前，请确保没有其他的 LiveReload 服务器在运行。如果从 IDE 启动多个应用，那么只有第一个获得 LiveReload 支持。

## 20.4、全局设置

通过添加名为 .spring-boot-devtools.properties 的文件到 $HOME 目录，可以配置全局 devtools 设置（注意，文件名以“.”开始）。添加到此文件中的任何属性都被应用到你电脑上使用 devtools 的所有 Spring Boot 应用。例如，要将 restart 配置为始终使用触发器文件，可以添加以下属性（在文件 ~/.spring-boot-devtools.properties 中添加）：

    spring.devtools.reload.trigger-file=.reloadtrigger

注释：在 .spring-boot-devtools.properties 中激活的配置不会影响特定配置（profile-specific）的配置文件的加载。

## 20.5、远程应用程序

Spring Boot 开发者工具不限于本地开发。当远程地运行应用时，还能够使用一些功能。远程支持是可选的。要启用它，需要确保再打包的归档文件中包含 devtools，如下面清单所示：

    <build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludeDevtools>false</excludeDevtools>
            </configuration>
        </plugin>
    </plugins>
    </build>

然后，你需要设置 spring.devtools.remote.secret 属性，如下面示例所示：

    spring.devtools.remote.secret=mysecret

警告：在远程应用上启用 spring-boot-devtools 是有安全风险的。你应当从不在生产部署上启用该支持。

远程 devtools 支持分为两部分：接受连接的服务器端端点，在 IDE 中运行的客户端应用程序。当设置 spring.devtools.remote.secret 属性时，服务器组件是自动启用的。客户端组件必须手动启动。

### 20.5.1、运行远程客户端应用程序

远程客户端应用程序设计为从 IDE 中运行。你需要使用与连接到的远程项目相同的类路径运行 org.springframework.boot.devtools.RemoteSpringApplication。应用程序的唯一必需参数是它连接到的远程 URL。

例如，如果你使用的是 Eclipse 或 STS， 并且有一个名为 my-app 的项目已部署到 Cloud Foundry，那么你将执行以下操作：

	（1）从“运行”菜单选择“运行配置...”。
	（2）创建一个新的“Java 应用程序”“启动配置”。
	（3）浏览项目 my-app。
	（4）将 org.springframework.boot.devtools.RemoteSpringApplication 用作主类。
	（5）将 https://myapp.cfapps.io 添加到“程序参数”（或者你自己的远程 URL）。

正在运行的远程客户端可能类似于以下清单：

    .   ____          _                                              __ _ _
    /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \
    ( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \
    \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )
    '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /
    =========|_|==============|___/===================================/_/_/_/
    :: Spring Boot Remote :: 2.1.6.RELEASE
    
    2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)
    2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy
    2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.
    2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
    2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)

注释：因为远程客户端使用与实际应用程序相同的类路径，所以它可以直接读取应用程序属性。这就是读取 spring.devtools.remote.secret 属性并将其传递给服务器进行身份验证的方式。

提示：建议始终使用 https:// 作为连接协议，以便对通信进行加密，并且不能截获密码。

提示：如果需要使用代理来访问远程应用，则请配置 spring.devtools.remote.proxy.host 和 spring.devtools.remote.proxy.port 属性。

### 20.5.2、远程更新

远程客户端以与本地重启相同的方式监视应用程序类路径的更改。任何已更新的资源都会被推送到远程应用并（如果需要）触发重启。如果你在一个使用非本地的云服务的功能上进行迭代，这是可能是有用的。通常，远程更新和重启要比完全重新构建和部署周期快得多。

注释：只有在远程客户端运行时才会监视文件。如果在启动远程客户端之前更改文件，则不会将其推送到远程服务器。
